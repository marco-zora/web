

@page "/upload"
@using Microsoft.AspNetCore.Components.Forms
@using System.Text
@using System.Xml.Linq
@using System.Net.Http.Headers
@implements IAsyncDisposable
@inject NavigationManager Nav
@inject HttpClient Http
@inject IJSRuntime JS

<h3>Carica i tuoi file</h3>


@inject IJSRuntime JS
@inject NavigationManager Nav

@code {
    protected override async Task OnInitializedAsync()
    {
        var user = await JS.InvokeAsync<string>("sessionStorage.getItem", "loggedUser");

        if (string.IsNullOrEmpty(user))
        {
            Nav.NavigateTo("/login");
            return;
        }
    }
}




<!-- Pulsante OneDrive -->
<button class="btn btn-primary" @onclick="ApriOneDrive">
    Carica su OneDrive (File Request)
</button>

<!-- Pulsante Nextcloud -->
<label class="btn btn-secondary ms-2" for="nc-file-input">
    Scegli file e carica su Nextcloud
</label>
<InputFile id="nc-file-input" OnChange="HandleNextcloudUpload" multiple style="display:none" />

<span class="ms-2">@Status</span>

<hr />

<!-- Barra strumenti gestione -->
<div class="d-flex align-items-center mb-2 gap-2">
    <button class="btn btn-outline-primary btn-sm" @onclick="RefreshListAsync">Aggiorna elenco</button>
    <span class="text-muted">@LastListRefreshText</span>
</div>




<!-- Toggle anteprime animate -->
<input class="form-check-input" type="checkbox" id="toggle-animated"
       @bind="AnimatedPreviews"
       @bind:after="OnAnimatedChanged">
<label class="form-check-label" for="toggle-animated">
    Anteprime animate (riproduci video quando visibili)
</label>


@if (Loading)
{
    <p>Caricamento elenco…</p>
}
else if (!string.IsNullOrEmpty(ListError))
{
    <p class="text-danger">@ListError</p>
}
else
{
    @if (Items.Count == 0)
    {
        <p>Nessun file in <code>UPLOADS</code>.</p>
    }
    else
    {
        <table class="table table-sm align-middle">
            <thead>
                <tr>
                    <th style="width:140px;">Anteprima</th>
                    <th>Nome</th>
                    <th class="text-end">Dimensione</th>
                    <th>Ultima modifica</th>
                    <th class="text-end">Azioni</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var it in Items)
                {
                    var isVid = IsVideo(it.ContentType, it.Name);
                    var fileUrl = FileUrl(it.Name);
                    var vidId = $"vid_{Uri.EscapeDataString(it.Name)}"; // id stabile per observer
                    <tr>
                        <td>
                            @if (isVid)
                            {
                                <!-- Miniatura statica: NESSUN autoplay; decide JS in base alla visibilità -->
                                <video id="@vidId"
                                       data-preview="1"
                                       muted
                                       playsinline
                                       loop
                                       preload="metadata"
                                       src="@fileUrl"
                                       style="width:130px; height:74px; border-radius:6px; background:#000; object-fit:cover;">
                                    Il tuo browser non supporta il video.
                                </video>
                            }
                            else
                            {
                                <!-- Placeholder per non-video -->
                                <div class="d-flex align-items-center justify-content-center"
                                     style="width:130px; height:74px; border:1px solid #e0e0e0; border-radius:6px; color:#999;">
                                    —
                                </div>
                            }
                        </td>
                        <td>@it.Name</td>
                        <td class="text-end">@FormatSize(it.Size)</td>
                        <td>@(it.LastModified?.ToLocalTime().ToString("yyyy-MM-dd HH:mm") ?? "")</td>
                        <td class="text-end">
                            <button class="btn btn-link btn-sm" @onclick="() => ViewAsync(it)">Visualizza</button>
                            <button class="btn btn-link btn-sm" @onclick="() => DownloadAsync(it.Name)">Scarica</button>
                            <button class="btn btn-link btn-sm text-danger" @onclick="() => DeleteAsync(it.Name)">Elimina</button>
                            <button class="btn btn-link btn-sm" @onclick="() => RenameAsync(it.Name)">Rinomina</button>
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    }
}

<!-- Modal Viewer -->
@if (ShowViewer && SelectedItem is not null)
{
    <div class="modal fade show d-block" tabindex="-1" style="background: rgba(0,0,0,0.55);">
        <div class="modal-dialog modal-xl modal-dialog-centered">
            <div class="modal-content">

                <!-- HEADER -->
                <div class="modal-header">
                    <h5 class="modal-title">Visualizza: @SelectedItem.Name</h5>
                    <button type="button" class="btn-close" @onclick="CloseViewer" aria-label="Close"></button>
                </div>

                <!-- BODY -->
                <div class="modal-body">
                    @if (IsVideo(SelectedItem.ContentType, SelectedItem.Name))
                    {
                        <video controls autoplay playsinline style="width:100%; max-height:70vh; background:#000;"
                               src="@FileUrl(SelectedItem.Name)">
                            Il tuo browser non supporta il video.
                        </video>
                    }
                    else
                    {
                        <div class="alert alert-info">
                            Questo file non è un video.
                            <a class="alert-link" href="@FileUrl(SelectedItem.Name)" target="_blank" rel="noopener">Aprilo in una nuova scheda</a>.
                        </div>
                    }
                </div>

                <!-- FOOTER -->
                <div class="modal-footer">
                    <button class="btn btn-secondary" @onclick="CloseViewer">Chiudi</button>
                    <a class="btn btn-outline-primary" href="@FileUrl(SelectedItem.Name)" target="_blank" rel="noopener">
                        Apri in nuova scheda
                    </a>
                </div>

            </div>
        </div>
    </div>
}

@code {
    // === OneDrive ===
    private string oneDriveFileRequestUrl =
        "https://cnrsc-my.sharepoint.com/:f:/g/personal/marcomaria_zora_cnr_it/IgBduHaMs9w8Rrv0sGzseFl0AdC6oy9w5_UP0wngjZvbgjQ";
    void ApriOneDrive() => Nav.NavigateTo(oneDriveFileRequestUrl, forceLoad: true);

    // === Nextcloud via Cloudflare Worker ===
    // ⚠️ Tenere /api/dav/ e lo slash finale
    private string ProxyBase = "https://first.marcomaria-zora.workers.dev/api/dav/";

    private string Status = "";
    private bool Loading = false;
    private string? ListError = null;
    private string LastListRefreshText = "";

    // Modello per la lista
    private List<DavItem> Items = new();

    private record DavItem(string Name, bool IsFile, long Size, DateTimeOffset? LastModified, string? ContentType);

    // ===== Upload (supporta multipli) ====
    private async Task HandleNextcloudUpload(InputFileChangeEventArgs e)
    {
        if (e is null) return;

        var files = e.GetMultipleFiles();
        if (files is null || files.Count == 0) return;

        int ok = 0, ko = 0;
        Status = "Caricamento in corso…";

        foreach (var file in files)
        {
            try
            {
                var url = new Uri(ProxyBase + "UPLOADS/" + Uri.EscapeDataString(file.Name));
                using var stream = file.OpenReadStream(long.MaxValue); // valuta chunk+progress in futuro
                using var content = new StreamContent(stream);
                content.Headers.ContentType = new MediaTypeHeaderValue("application/octet-stream");

                var res = await Http.PutAsync(url, content);
                if (res.IsSuccessStatusCode) ok++; else ko++;
            }
            catch
            {
                ko++;
            }
        }

        if (ko == 0)
            Status = files.Count == 1 ? $"Caricato su Nextcloud: {files[0].Name}" : $"Caricati {ok} file su Nextcloud";
        else
            Status = $"Caricati: {ok}, Falliti: {ko}";

        await RefreshListAsync(); // aggiorna elenco dopo upload
    }

    // ===== Lista (PROPFIND Depth:1) ====
    private async Task RefreshListAsync()
    {
        Loading = true;
        ListError = null;
        try
        {
            var url = new Uri(ProxyBase + "UPLOADS/");

            // XML reale + MIME corretto + getcontenttype
            const string body = @"<?xml version=""1.0"" encoding=""utf-8""?>
<d:propfind xmlns:d=""DAV:"">
  <d:prop>
    <d:displayname/>
    <d:resourcetype/>
    <d:getcontentlength/>
    <d:getlastmodified/>
    <d:getcontenttype/>
  </d:prop>
</d:propfind>";

            using var req = new HttpRequestMessage(HttpMethod.Post, url);
            req.Headers.Add("X-Method-Override", "PROPFIND");
            req.Headers.Add("Depth", "1");
            req.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue("application/xml"));
            req.Content = new StringContent(body, Encoding.UTF8, "application/xml");

            var res = await Http.SendAsync(req);
            if (!res.IsSuccessStatusCode)
            {
                ListError = $"Errore elenco {(int)res.StatusCode} {res.ReasonPhrase}";
                Items.Clear();
                return;
            }

            var xml = await res.Content.ReadAsStringAsync();
            Items = ParsePropfind(xml);
            LastListRefreshText = $"(aggiornato alle {DateTime.Now:HH:mm:ss})";
        }
        catch (Exception ex)
        {
            ListError = ex.Message;
            Items.Clear();
        }
        finally
        {
            Loading = false;
        }
    }

    private static List<DavItem> ParsePropfind(string xml)
    {
        var list = new List<DavItem>();
        var doc = XDocument.Parse(xml);
        XNamespace d = "DAV:";

        foreach (var resp in doc.Descendants(d + "response"))
        {
            var href = resp.Element(d + "href")?.Value ?? "";
            if (string.IsNullOrWhiteSpace(href))
                continue;

            // Scegliamo il propstat 200 OK
            var propstat = resp.Elements(d + "propstat")
                               .FirstOrDefault(ps =>
                                   (string?)ps.Element(d + "status") != null &&
                                   ps.Element(d + "status")!.Value.Contains("200"));

            if (propstat == null) continue;

            var prop = propstat.Element(d + "prop");
            if (prop == null) continue;

            // Nome dal displayname o dall'href
            var displayName = prop.Element(d + "displayname")?.Value ?? "";
            var decodedHref = Uri.UnescapeDataString(href);
            var nameFromHref = decodedHref.TrimEnd('/')
                                          .Split('/', StringSplitOptions.RemoveEmptyEntries)
                                          .LastOrDefault() ?? "";

            var name = string.IsNullOrWhiteSpace(displayName) ? nameFromHref : displayName;

            // Cartelle (collection) → saltate
            var isCollection = prop.Element(d + "resourcetype")?.Element(d + "collection") != null;
            if (isCollection) continue;

            // Dimensione
            long size = 0;
            var sizeStr = prop.Element(d + "getcontentlength")?.Value;
            if (!string.IsNullOrWhiteSpace(sizeStr))
                long.TryParse(sizeStr, out size);

            // Ultima modifica
            DateTimeOffset? lm = null;
            var lmStr = prop.Element(d + "getlastmodified")?.Value;
            if (!string.IsNullOrWhiteSpace(lmStr) && DateTimeOffset.TryParse(lmStr, out var lmv))
                lm = lmv;

            // Content-Type
            var ctype = prop.Element(d + "getcontenttype")?.Value;

            // Evita la voce radice
            if (string.IsNullOrWhiteSpace(name) || name.Equals("UPLOADS", StringComparison.OrdinalIgnoreCase))
                continue;

            list.Add(new DavItem(name, IsFile: true, Size: size, LastModified: lm, ContentType: ctype));
        }

        // Ordina per data discendente
        return list.OrderByDescending(i => i.LastModified).ToList();
    }

    // ===== Download (apre in nuova scheda) ====
    private async Task DownloadAsync(string name)
    {
        await JS.InvokeVoidAsync("open", FileUrl(name), "_blank");
    }

    // ===== Delete ====
    private async Task DeleteAsync(string name)
    {
        var conferma = await JS.InvokeAsync<bool>("confirm", $"Eliminare '{name}'?");
        if (!conferma) return;

        var url = new Uri(FileUrl(name));
        var res = await Http.DeleteAsync(url);
        if (res.IsSuccessStatusCode)
        {
            Status = $"Eliminato: {name}";
            await RefreshListAsync();
        }
        else
        {
            Status = $"Errore eliminazione {(int)res.StatusCode} {res.ReasonPhrase}";
        }
    }

    // ===== Rename (MOVE) ====
    private async Task RenameAsync(string oldName)
    {
        var newName = await JS.InvokeAsync<string?>("prompt", $"Nuovo nome per '{oldName}':", oldName);
        if (string.IsNullOrWhiteSpace(newName) || newName == oldName) return;

        // Sanitizzazione minima
        newName = newName.Trim();
        if (newName.Contains('/') || newName.Contains('\\') || newName.Contains(".."))
        {
            Status = "Nome non valido. Evita /, \\ e ..";
            return;
        }

        var src = new Uri(FileUrl(oldName));
        var dstUri = new Uri(FileUrl(newName));

        using var req = new HttpRequestMessage(HttpMethod.Post, src);
        req.Headers.Add("X-Method-Override", "MOVE");
        req.Headers.TryAddWithoutValidation("Destination", dstUri.AbsoluteUri);
        req.Headers.Add("Overwrite", "T");
        req.Headers.TryAddWithoutValidation("Accept", "application/xml");

        var res = await Http.SendAsync(req);
        if (res.IsSuccessStatusCode)
        {
            Status = $"Rinominato in: {newName}";
            await RefreshListAsync();
        }
        else
        {
            var body = await res.Content.ReadAsStringAsync();
            Status = $"Errore rinomina {(int)res.StatusCode} {res.ReasonPhrase}";
            // Console.WriteLine(body);
        }
    }

    // ===== Helpers / Viewer =====
    private static bool IsVideo(string? contentType, string name)
    {
        if (!string.IsNullOrEmpty(contentType) && contentType.StartsWith("video/", StringComparison.OrdinalIgnoreCase))
            return true;

        var ext = System.IO.Path.GetExtension(name).ToLowerInvariant();
        return ext is ".mp4" or ".webm" or ".ogg" or ".mov" or ".m4v";
    }

    private string FileUrl(string name)
        => ProxyBase + "UPLOADS/" + Uri.EscapeDataString(name);

    private bool ShowViewer = false;
    private DavItem? SelectedItem = null;

    private async Task ViewAsync(DavItem item)
    {
        SelectedItem = item;
        ShowViewer = true;
        await InvokeAsync(StateHasChanged);
    }

    private void CloseViewer()
    {
        ShowViewer = false;
        SelectedItem = null;
    }

    // ===== Anteprime animate (JS interop) =====
    private bool AnimatedPreviews = false;

    private async Task OnAnimatedChanged()
        => await JS.InvokeVoidAsync("previewObserver.setAnimated", AnimatedPreviews);

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JS.InvokeVoidAsync("previewObserver.init");
        }
        // Scansiona ad ogni render: registra i nuovi <video data-preview="1">
        await JS.InvokeVoidAsync("previewObserver.scan");
    }

    public async ValueTask DisposeAsync()
    {
        try { await JS.InvokeVoidAsync("previewObserver.dispose"); }
        catch { /* ignore on dispose */ }
    }

    // ===== Utilità ====
    private static string FormatSize(long bytes)
    {
        if (bytes < 1024) return $"{bytes} B";
        double kb = bytes / 1024d;
        if (kb < 1024) return $"{kb:0.0} KB";
        double mb = kb / 1024d;
        if (mb < 1024) return $"{mb:0.0} MB";
        double gb = mb / 1024d;
        return $"{gb:0.0} GB";
    }

    // Carica lista iniziale alla prima apertura
    protected override async Task OnInitializedAsync() => await RefreshListAsync();
}

