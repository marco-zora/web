@page "/upload"
@using Microsoft.AspNetCore.Components.Forms
@using System.Text
@using System.Xml.Linq
@using System.Net.Http.Headers
@inject NavigationManager Nav
@inject HttpClient Http
@inject IJSRuntime JS

<h3>Carica i tuoi file</h3>

<!-- Pulsante OneDrive -->
<button class="btn btn-primary" @onclick="ApriOneDrive">
    Carica su OneDrive (File Request)
</button>

<!-- Pulsante Nextcloud -->
<label class="btn btn-secondary ms-2" for="nc-file-input">
    Scegli file e carica su Nextcloud
</label>
<InputFile id="nc-file-input" OnChange="HandleNextcloudUpload" multiple style="display:none" />

<span class="ms-2">@Status</span>

<hr />

<!-- Barra strumenti gestione -->
<div class="d-flex align-items-center mb-2">
    <button class="btn btn-outline-primary btn-sm" @onclick="RefreshListAsync">Aggiorna elenco</button>
    <span class="ms-2 text-muted">@LastListRefreshText</span>
</div>

@if (Loading)
{
    <p>Caricamento elenco…</p>
}
else if (!string.IsNullOrEmpty(ListError))
{
    <p class="text-danger">@ListError</p>
}
else
{
    @if (Items.Count == 0)
    {
        <p>Nessun file in <code>UPLOADS</code>.</p>
    }
    else
    {
        <table class="table table-sm align-middle">
            <thead>
                <tr>
                    <th>Nome</th>
                    <th class="text-end">Dimensione</th>
                    <th>Ultima modifica</th>
                    <th class="text-end">Azioni</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var it in Items)
                {
                    <tr>
                        <td>@it.Name</td>
                        <td class="text-end">@FormatSize(it.Size)</td>
                        <td>@(it.LastModified?.ToLocalTime().ToString("yyyy-MM-dd HH:mm") ?? "")</td>
                        <td class="text-end">
                            <button class="btn btn-link btn-sm" @onclick="() => DownloadAsync(it.Name)">Scarica</button>
                            <button class="btn btn-link btn-sm text-danger" @onclick="() => DeleteAsync(it.Name)">Elimina</button>
                            <button class="btn btn-link btn-sm" @onclick="() => RenameAsync(it.Name)">Rinomina</button>
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    }
}

@code {
    // === OneDrive ===
    private string oneDriveFileRequestUrl =
        "https://cnrsc-my.sharepoint.com/:f:/g/personal/marcomaria_zora_cnr_it/IgBduHaMs9w8Rrv0sGzseFl0AdC6oy9w5_UP0wngjZvbgjQ";
    void ApriOneDrive() => Nav.NavigateTo(oneDriveFileRequestUrl, forceLoad: true);

    // === Nextcloud via Cloudflare Worker ===
    // ⚠️ Tenere /api/dav/ e lo slash finale
    private string ProxyBase = "https://first.marcomaria-zora.workers.dev/api/dav/";

    private string Status = "";
    private bool Loading = false;
    private string? ListError = null;
    private string LastListRefreshText = "";

    // Modello per la lista
    private List<DavItem> Items = new();

    private record DavItem(string Name, bool IsFile, long Size, DateTimeOffset? LastModified);

    // ===== Upload (supporta multipli) ====
    private async Task HandleNextcloudUpload(InputFileChangeEventArgs e)
    {
        if (e is null) return;

        var files = e.GetMultipleFiles();
        if (files is null || files.Count == 0) return;

        int ok = 0, ko = 0;
        Status = "Caricamento in corso…";

        foreach (var file in files)
        {
            try
            {
                var url = new Uri(ProxyBase + "UPLOADS/" + Uri.EscapeDataString(file.Name));
                using var stream = file.OpenReadStream(long.MaxValue); // considera chunk/progress in futuro
                using var content = new StreamContent(stream);
                content.Headers.ContentType = new MediaTypeHeaderValue("application/octet-stream");

                var res = await Http.PutAsync(url, content);
                if (res.IsSuccessStatusCode) ok++; else ko++;
            }
            catch
            {
                ko++;
            }
        }

        if (ko == 0)
            Status = files.Count == 1 ? $"Caricato su Nextcloud: {files[0].Name}" : $"Caricati {ok} file su Nextcloud";
        else
            Status = $"Caricati: {ok}, Falliti: {ko}";

        await RefreshListAsync(); // aggiorna elenco dopo upload
    }

    // ===== Lista (PROPFIND Depth:1) ====
    private async Task RefreshListAsync()
    {
        Loading = true;
        ListError = null;
        try
        {
            var url = new Uri(ProxyBase + "UPLOADS/");

            // XML reale + MIME corretto
            const string body = @"<?xml version=""1.0"" encoding=""utf-8""?>
<d:propfind xmlns:d=""DAV:"">
  <d:prop>
    <d:displayname/>
    <d:resourcetype/>
    <d:getcontentlength/>
    <d:getlastmodified/>
  </d:prop>
</d:propfind>";

            using var req = new HttpRequestMessage(HttpMethod.Post, url);
            req.Headers.Add("X-Method-Override", "PROPFIND");
            req.Headers.Add("Depth", "1");
            req.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue("application/xml"));
            req.Content = new StringContent(body, Encoding.UTF8, "application/xml");

            var res = await Http.SendAsync(req);
            if (!res.IsSuccessStatusCode)
            {
                ListError = $"Errore elenco {(int)res.StatusCode} {res.ReasonPhrase}";
                Items.Clear();
                return;
            }

            var xml = await res.Content.ReadAsStringAsync();
            Items = ParsePropfind(xml);
            LastListRefreshText = $"(aggiornato alle {DateTime.Now:HH:mm:ss})";
        }
        catch (Exception ex)
        {
            ListError = ex.Message;
            Items.Clear();
        }
        finally
        {
            Loading = false;
        }
    }

    private static List<DavItem> ParsePropfind(string xml)
    {
        var list = new List<DavItem>();
        var doc = XDocument.Parse(xml);
        XNamespace d = "DAV:";

        foreach (var resp in doc.Descendants(d + "response"))
        {
            var href = resp.Element(d + "href")?.Value ?? "";
            if (string.IsNullOrWhiteSpace(href))
                continue;

            // Scegliamo il propstat 200 OK
            var propstat = resp.Elements(d + "propstat")
                               .FirstOrDefault(ps =>
                                   (string?)ps.Element(d + "status") != null &&
                                   ps.Element(d + "status")!.Value.Contains("200"));

            if (propstat == null) continue;

            var prop = propstat.Element(d + "prop");
            if (prop == null) continue;

            // Nome dal displayname o dall'href
            var displayName = prop.Element(d + "displayname")?.Value ?? "";
            var decodedHref = Uri.UnescapeDataString(href);
            var nameFromHref = decodedHref.TrimEnd('/')
                                          .Split('/', StringSplitOptions.RemoveEmptyEntries)
                                          .LastOrDefault() ?? "";

            var name = string.IsNullOrWhiteSpace(displayName) ? nameFromHref : displayName;

            // Cartelle (collection) → saltate
            var isCollection = prop.Element(d + "resourcetype")?.Element(d + "collection") != null;
            if (isCollection) continue;

            // Dimensione
            long size = 0;
            var sizeStr = prop.Element(d + "getcontentlength")?.Value;
            if (!string.IsNullOrWhiteSpace(sizeStr))
                long.TryParse(sizeStr, out size);

            // Ultima modifica
            DateTimeOffset? lm = null;
            var lmStr = prop.Element(d + "getlastmodified")?.Value;
            if (!string.IsNullOrWhiteSpace(lmStr) && DateTimeOffset.TryParse(lmStr, out var lmv))
                lm = lmv;

            // Evita la voce radice
            if (string.IsNullOrWhiteSpace(name) || name.Equals("UPLOADS", StringComparison.OrdinalIgnoreCase))
                continue;

            list.Add(new DavItem(name, IsFile: true, Size: size, LastModified: lm));
        }

        // Ordina per data discendente
        return list.OrderByDescending(i => i.LastModified).ToList();
    }

    // ===== Download (apre in nuova scheda) ====
    private async Task DownloadAsync(string name)
    {
        var url = ProxyBase + "UPLOADS/" + Uri.EscapeDataString(name);
        await JS.InvokeVoidAsync("open", url, "_blank");
    }

    // ===== Delete ====
    private async Task DeleteAsync(string name)
    {
        var conferma = await JS.InvokeAsync<bool>("confirm", $"Eliminare '{name}'?");
        if (!conferma) return;

        var url = new Uri(ProxyBase + "UPLOADS/" + Uri.EscapeDataString(name));
        var res = await Http.DeleteAsync(url);
        if (res.IsSuccessStatusCode)
        {
            Status = $"Eliminato: {name}";
            await RefreshListAsync();
        }
        else
        {
            Status = $"Errore eliminazione {(int)res.StatusCode} {res.ReasonPhrase}";
        }
    }

    // ===== Rename (MOVE) ====
    private async Task RenameAsync(string oldName)
    {
        var newName = await JS.InvokeAsync<string?>("prompt", $"Nuovo nome per '{oldName}':", oldName);
        if (string.IsNullOrWhiteSpace(newName) || newName == oldName) return;

        // Sanitizzazione minima
        newName = newName.Trim();
        if (newName.Contains('/') || newName.Contains('\\') || newName.Contains(".."))
        {
            Status = "Nome non valido. Evita /, \\ e ..";
            return;
        }

        var src = new Uri(ProxyBase + "UPLOADS/" + Uri.EscapeDataString(oldName));
        var dstUri = new Uri(ProxyBase + "UPLOADS/" + Uri.EscapeDataString(newName));

        using var req = new HttpRequestMessage(HttpMethod.Post, src);
        req.Headers.Add("X-Method-Override", "MOVE");
        req.Headers.TryAddWithoutValidation("Destination", dstUri.AbsoluteUri);
        req.Headers.Add("Overwrite", "T");
        req.Headers.TryAddWithoutValidation("Accept", "application/xml");

        var res = await Http.SendAsync(req);
        if (res.IsSuccessStatusCode)
        {
            Status = $"Rinominato in: {newName}";
            await RefreshListAsync();
        }
        else
        {
            var body = await res.Content.ReadAsStringAsync();
            Status = $"Errore rinomina {(int)res.StatusCode} {res.ReasonPhrase}";
            // Console.WriteLine(body); // utile per debug
        }
    }

    // ===== Utilità ====
    private static string FormatSize(long bytes)
    {
        if (bytes < 1024) return $"{bytes} B";
        double kb = bytes / 1024d;
        if (kb < 1024) return $"{kb:0.0} KB";
        double mb = kb / 1024d;
        if (mb < 1024) return $"{mb:0.0} MB";
        double gb = mb / 1024d;
        return $"{gb:0.0} GB";
    }

    // Carica lista iniziale alla prima apertura
    protected override async Task OnInitializedAsync() => await RefreshListAsync();
}
``
